# -*- coding: utf-8 -*-
"""livia_projeto_final_tel√≥s.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ikm9YnOPb51qtbTr9gBh4wmh3pTUkRJl

##Importanto Bibliotecas
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""##Importando as bases"""

df_compras = pd.read_excel('/content/COMPRAS_865e1d278d.xlsx')
df_cadastral = pd.read_excel('/content/CADASTRAL.xlsx')
df_campanhas = pd.read_excel('/content/CAMPANHAS.xlsx')
df_reclamacoes = pd.read_excel('/content/RECLAMACOES.xlsx')

"""##EDA (An√°lise Explor√°toria)"""

#Eda DF_COMPRAS
# Quantidade de Linhas
num_linhas = df_compras.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_compras.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_compras.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_compras.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_compras.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna data_compra
print("Intervalo de datas da coluna data de compra:")
print("Data m√≠nima:", df_compras["data_compra"].min())
print("Data m√°xima:", df_compras["data_compra"].max())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_compras.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data m√≠nima:", df_compras["TIMESTAMP"].min())
    print("Data m√°xima:", df_compras["TIMESTAMP"].max())

#Eda DF_CADASTRAL
# Quantidade de Linhas
num_linhas = df_cadastral.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_cadastral.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_cadastral.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_cadastral.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_cadastral.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_compras.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data m√≠nima:", df_compras["TIMESTAMP"].min())
    print("Data m√°xima:", df_compras["TIMESTAMP"].max())

#Eda DF_CAMPANHAS
# Quantidade de Linhas
num_linhas = df_campanhas.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_campanhas.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_campanhas.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_campanhas.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_campanhas.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna data_compra
print("Intervalo de datas da coluna data de compra:")
print("Data m√≠nima:", df_campanhas["data_envio"].min())
print("Data m√°xima:", df_campanhas["data_envio"].max())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_campanhas.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data m√≠nima:", df_campanhas["TIMESTAMP"].min())
    print("Data m√°xima:", df_campanhas["TIMESTAMP"].max())

#Eda df_reclamacoes
# Quantidade de Linhas
num_linhas = df_reclamacoes.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_reclamacoes.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_reclamacoes.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_reclamacoes.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_reclamacoes.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna data_compra
print("Intervalo de datas da coluna data de compra:")
print("Data m√≠nima:", df_reclamacoes["data_reclamacao"].min())
print("Data m√°xima:", df_reclamacoes["data_reclamacao"].max())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_compras.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data m√≠nima:", df_reclamacoes["TIMESTAMP"].min())
    print("Data m√°xima:", df_reclamacoes["TIMESTAMP"].max())

from google.colab import drive
drive.mount('/content/drive')

"""##Tratamentos de dados"""

#Tratando df_compras. Identificando datas futuras
import datetime

# Pega a data de hoje
data_hoje = datetime.datetime.today()

# Filtra as linhas com data_compra maior que hoje
futuras = df_compras[df_compras['data_compra'] > data_hoje]

# Mostra a quantidade
print(f"N√∫mero de compras com data futura: {len(futuras)}")

# Remove as linhas com data_compra no futuro
df_compras = df_compras[df_compras['data_compra'] <= data_hoje]

# Mostra a quantidade
print(f"N√∫mero de compras com data futura: {len(futuras)}")

print(df_cadastral.dtypes)

#Dropando colunas " " e ".1"(Foi verificado no Google Sheets que as colunas estavam vazias)
df_cadastral = df_cadastral.drop(columns=[' ', ' .1'])

df_cadastral.columns

"""checando duplicatas"""

df_cadastral.duplicated().sum()

df_reclamacoes.duplicated().sum()

df_campanhas.duplicated().sum()

df_compras.duplicated().sum()

df_compras.dtypes

#Altera a coluna valor_compra de object para float
df_compras['valor_compra'] = df_compras['valor_compra'].astype(float)

df_compras['valor_compra'].apply(type).value_counts()#Investigando a coluna valor_compra

# Remove do DataFrame as linhas onde 'valor_compra' n√£o pode ser convertida para float(40 linhas estavam com dados inconsistentes ent√£o eu os removi)
# Garante que apenas valores num√©ricos v√°lidos permane√ßam na coluna.

def is_valor_valido(valor):
    try:
        float(valor)  # testa apenas se pode ser convertido para float
        return True
    except:
        return False

# Mant√©m somente as linhas com valores num√©ricos v√°lidos
df_compras = df_compras[df_compras['valor_compra'].apply(is_valor_valido)]

#Altera o tipo de object para float
df_compras['valor_compra'] = df_compras['valor_compra'].astype(float)

df_compras.dtypes  #verificando se o tipo foi alterado

#Contas valores nulos no df_campanhas
df_campanhas.isnull().sum()

#Investigando as linhas inconsistentes(valores nulos)
linhas_inconsistentes = df_campanhas[
    df_campanhas['tema_campanha'].isnull() |
    df_campanhas['clicou'].isnull()
]

#Dropando linhas nulas
df_campanhas = df_campanhas.drop(linhas_inconsistentes.index)

#verificando se linhas foram excluidas
df_campanhas.isnull().sum()

#verificando valores nulos no df_reclama√ß√£o
df_reclamacoes.isnull().sum()

#Investigando as linhas inconsistentes(valores nulos) no df_reclamacoes
linhas_inconsistentesrec = df_reclamacoes[
    df_reclamacoes['tipo_reclamacao'].isnull() ]

print(f"Linhas inconsistentes: {len(linhas_inconsistentesrec)}")

#dropando linhas com valores nulos
df_reclamacoes = df_reclamacoes.drop(linhas_inconsistentesrec.index)

#Checando se o drop deu certo
df_reclamacoes.isnull().sum()

"""##Criando Colunas"""

#nCria nova coluna booleana para SEXO
# Padroniza e converte: masculino = True, feminino = False
df_cadastral['sexo_bool'] = df_cadastral['sexo'].str.strip().str.lower().map({
    'masculino': True,
    'feminino': False
})

#Cria 3 novas colunas booleanas para abriu, clicou, converteu_em_compra
for col in ['abriu', 'clicou', 'converteu_em_compra']:
    df_campanhas[col + '_bool'] = df_campanhas[col].str.strip().str.lower().map({
        'sim': True,
        'n√£o': False
    })

# Agora cria a coluna 'ano_mes' no formato 'YYYY-MM'
df_compras['ano_mes'] = df_compras['data_compra'].dt.to_period('M').astype(str)

#Cria coluna ano_mes referente a data de reclama√ß√£o.
df_reclamacoes['ano_mes'] = df_reclamacoes['data_reclamacao'].dt.to_period('M').astype(str)

"""#Agrupamentos"""

#Agrupar total de gastos por cliente
# Agrupar por cliente e somar o valor das compras
total_gasto_cliente = df_compras.groupby('cliente_id')['valor_compra'].sum().reset_index()

# Renomear a coluna para facilitar o uso depois
total_gasto_cliente.columns = ['cliente_id', 'total_gasto_cliente']

#Verifica qual faixa et√°ria mais frequente dos clientes
df_cadastral['faixa_etaria'].value_counts()

#Conta o status de entrega
df_compras['status_entrega'].value_counts()

#Agrupa a quantidade de reclama√ß√£o por cliente
qtd_reclamacoes = df_reclamacoes.groupby('cliente_id').size().reset_index(name='qtd_reclamacoes')

#Verifica qual canal de reclama√ß√£o √© o mais utilizado
canal_fav = (
    df_reclamacoes.groupby(['cliente_id', 'canal_reclamacao'])
    .size()
    .reset_index(name='qtd')
    .sort_values(['cliente_id', 'qtd'], ascending=[True, False])
    .drop_duplicates('cliente_id')
    .rename(columns={'canal_reclamacao': 'canal_mais_usado_reclamacao'})
)

#Quais canais de campanhas de marketing mais convertem
# Ensure 'converteu_em_compra' is in a suitable format (boolean) for summation
df_campanhas['converteu_em_compra_bool'] = df_campanhas['converteu_em_compra'].str.strip().str.lower().map({
    'sim': True,
    'n√£o': False
})

canal_conv = df_campanhas.groupby('canal').agg(
    total_envios=('cliente_id', 'count'),
    total_conversoes=('converteu_em_compra_bool', 'sum') # Sum the boolean column
).reset_index()

canal_conv['taxa_conversao'] = (canal_conv['total_conversoes'] / canal_conv['total_envios']) * 100

# Visualizar ordenado
canal_conv.sort_values(by='taxa_conversao', ascending=False)

# Total de compras por cliente
compras_agg = df_compras.groupby('cliente_id').agg({
    'valor_compra': 'sum',
    'data_compra': 'count',
    'quantidade_parcelas': 'sum'
}).rename(columns={
    'valor_compra': 'total_gasto',
    'data_compra': 'num_compras',
    'quantidade_parcelas': 'total_parcelas'
})

# Total de convers√µes por cliente
campanhas_agg = df_campanhas.groupby('cliente_id').agg({
    'converteu_em_compra_bool': 'sum'
}).rename(columns={'converteu_em_compra_bool': 'total_conversoes'})

# Merge com df_cadastral
df_financeiro = df_cadastral.merge(compras_agg, on='cliente_id', how='left') \
                            .merge(campanhas_agg, on='cliente_id', how='left')

#A partir desse c√≥digo come√ßa um relacionamento entre clientes inativos e score inicial
#Visa descobrir se a porcentagem de clientes inativos (71%) tem a ver com o score dos clientes(Que em sua maioria fica entre 400 e 500 pontos)
df_cadastral['status_cadastro'].value_counts()

#Cria dois grupos de clientes "Ativos e Inativos"
ativos = df_cadastral[df_cadastral['status_cadastro'] == 'Ativo']
inativos = df_cadastral[df_cadastral['status_cadastro'] == 'Inativo']

#M√©dia de Score por Grupo
df_cadastral.groupby('status_cadastro')['score_inicial'].mean()

"""# Visualiza√ß√µes"""

#Visualiza√ß√£o da quantidades de clientes cadastrados por faixa et√°ria
import matplotlib.pyplot as plt
import seaborn as sns

# Estilo
sns.set(style="whitegrid")

# Contagem por faixa et√°ria
contagem_faixas = df_cadastral['faixa_etaria'].value_counts().sort_index()

# Paleta azul, roxo e lil√°s (repete se tiver mais faixas)
cores_personalizadas = ['#6495ED', '#6A0DAD', '#C8A2C8'] * 3

# Cria a figura com fundo cinza claro
plt.figure(figsize=(10, 6), facecolor='#f2f2f2')

# Gr√°fico
ax = sns.barplot(
    x=contagem_faixas.index,
    y=contagem_faixas.values,
    palette=cores_personalizadas[:len(contagem_faixas)]
)

# Fundo do gr√°fico
ax.set_facecolor('#f9f9f9')

# T√≠tulos
plt.title('Distribui√ß√£o de Clientes por Faixa Et√°ria', fontsize=16, weight='bold')
plt.xlabel('Faixa Et√°ria', fontsize=12)
plt.ylabel('N√∫mero de Clientes', fontsize=12)
plt.xticks(rotation=45)

# Remove bordas extras
sns.despine()
plt.tight_layout()

plt.show()

#Distribui√ß√£o de Status de Entrega

# Contagem dos status de entrega
status_counts = df_compras['status_entrega'].value_counts()

# Cores personalizadas: azul, roxo e lil√°s
cores = ['#6495ED', '#6A0DAD', '#C8A2C8']

# Criar figura com fundo cinza claro
plt.figure(figsize=(7,7), facecolor='#f2f2f2')

# Plotar gr√°fico de pizza
plt.pie(
    status_counts,
    labels=status_counts.index,
    autopct='%1.1f%%',
    colors=cores,
    startangle=140,
    textprops={'color':"black", 'fontsize':12}
)

plt.title('Distribui√ß√£o do Status de Entrega', fontsize=16, weight='bold')

# Mostrar gr√°fico
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.font_manager as fm
import numpy as np

# Taxa de convers√£o por canal
canal_conv = df_campanhas.groupby('canal').agg(
    total_envios=('cliente_id', 'count'),
    total_conversoes=('converteu_em_compra_bool', 'sum')
).reset_index()

canal_conv['taxa_conversao'] = (canal_conv['total_conversoes'] / canal_conv['total_envios']) * 100

# Ordena pelo maior valor de taxa de convers√£o
canal_conv = canal_conv.sort_values('taxa_conversao', ascending=False).reset_index(drop=True)

# Gera√ß√£o de cores em degrad√™ (roxo escuro para lil√°s claro)
from matplotlib.colors import LinearSegmentedColormap

# Cria um gradiente de cores do roxo escuro ao lil√°s
cmap = LinearSegmentedColormap.from_list("roxo_lilas", ["#483D8B", "#D8BFD8"])
norm = plt.Normalize(canal_conv['taxa_conversao'].min(), canal_conv['taxa_conversao'].max())
colors = [cmap(norm(val)) for val in canal_conv['taxa_conversao']]

# Plot
plt.figure(figsize=(8, 5))
barplot = sns.barplot(
    data=canal_conv,
    x='taxa_conversao',
    y='canal',
    palette=colors
)

# Adiciona o percentual ao lado das barras
for i, valor in enumerate(canal_conv['taxa_conversao']):
    plt.text(valor + 0.5, i, f'{valor:.1f}%', va='center', fontsize=10, color='black')

# Fonte personalizada (DIN) se dispon√≠vel
# Substitua o caminho abaixo pelo caminho local da sua fonte, se necess√°rio
# fm.fontManager.addfont('/caminho/para/sua/fonte/DIN-Regular.ttf')
# plt.rcParams['font.family'] = 'DIN'

# Estilo do t√≠tulo
plt.title('üì° Taxa de Convers√£o por Canal de Campanha',
          fontsize=14, color='#4F4F4F', fontweight='bold', fontname='DIN')

plt.xlabel('Taxa de Convers√£o (%)')
plt.ylabel('Canal')
plt.grid(axis='x', linestyle='--', alpha=0.4)
plt.gca().set_facecolor('#f0f0f0')
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import matplotlib.font_manager as fm
import numpy as np

# Normaliza√ß√£o dos dados
df_campanhas['abriu'] = df_campanhas['abriu'].str.strip().str.lower()
df_campanhas['clicou'] = df_campanhas['clicou'].str.strip().str.lower()
df_campanhas['converteu_em_compra'] = df_campanhas['converteu_em_compra'].str.strip().str.lower()

# C√°lculo das taxas
abriu_sim = df_campanhas['abriu'].value_counts(normalize=True).get('sim', 0) * 100
clicou_sim = df_campanhas['clicou'].value_counts(normalize=True).get('sim', 0) * 100
converteu_sim = df_campanhas['converteu_em_compra'].value_counts(normalize=True).get('sim', 0) * 100

# Estrutura do funil
funnel_data = {
    'Etapa': ['Campanhas Enviadas', 'Campanhas Abertas', 'Cliques', 'Convers√µes'],
    'Taxa (%)': [100, abriu_sim, clicou_sim, converteu_sim]
}
funnel_df = pd.DataFrame(funnel_data)

# Degrad√™ de cores: roxo (valor alto) para lil√°s (valor baixo)
cmap = LinearSegmentedColormap.from_list("degrade_roxo_lilas", ['#6A0DAD', '#E6ADD8'])
norm = plt.Normalize(funnel_df['Taxa (%)'].min(), funnel_df['Taxa (%)'].max())
colors = [cmap(norm(val)) for val in funnel_df['Taxa (%)']]

# Plot
fig, ax = plt.subplots(figsize=(8, 6))
bars = ax.barh(funnel_df['Etapa'], funnel_df['Taxa (%)'], color=colors)

# R√≥tulos nas barras
for bar in bars:
    width = bar.get_width()
    ax.text(width - 3, bar.get_y() + bar.get_height()/2,
            f'{width:.1f}%', ha='right', va='center',
            fontsize=10, color='white')

# Fonte personalizada (DIN)
# Se a fonte DIN n√£o estiver instalada, substitua pelo caminho do arquivo .ttf:
# fm.fontManager.addfont('/caminho/para/DIN.ttf')
# plt.rcParams['font.family'] = 'DIN'
plt.title('üîª Funil de Engajamento e Convers√£o',
          fontsize=14, color='#4F4F4F', fontweight='bold', fontname='DIN')

# Estilo do gr√°fico
ax.set_xlim(0, 110)
ax.set_xlabel('Percentual (%)')
ax.set_facecolor('#f0f0f0')
plt.grid(axis='x', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.colors as mcolors
import numpy as np

# Ordenar os dados por taxa de convers√£o (do maior pro menor)
canal_conv = canal_conv.sort_values(by='taxa_conversao', ascending=False).reset_index(drop=True)

# Criar gradiente de roxo escuro at√© lil√°s com base na quantidade de canais
cmap = mcolors.LinearSegmentedColormap.from_list("roxo_lilas", ["#4B0082", "#D8BFD8"])  # Roxo escuro -> Lil√°s
cores_gradiente = [cmap(i / (len(canal_conv) - 1)) for i in range(len(canal_conv))]

# Estilo
sns.set(style="whitegrid")
plt.figure(figsize=(10, 6))
plt.gca().set_facecolor('#f7f7f7')  # Fundo cinza bem clarinho

# Criar o gr√°fico de barras
barras = sns.barplot(
    data=canal_conv,
    x='taxa_conversao',
    y='canal',
    palette=cores_gradiente
)

# Adicionar r√≥tulos de valor nas barras
for container in barras.containers:
    barras.bar_label(container, fmt="%.1f%%", label_type='edge', padding=5)

# T√≠tulos e labels
plt.title('Taxa de Convers√£o por Canal de Campanha', fontsize=14, weight='bold')
plt.xlabel('Taxa de Convers√£o (%)')
plt.ylabel('Canal')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
sns.histplot(
    data=df_cadastral,
    x='score_inicial',
    bins=30,
    kde=True,
    color='mediumpurple'
)
plt.title('Distribui√ß√£o do Score Inicial')
plt.xlabel('Score Inicial')
plt.ylabel('Quantidade de Clientes')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

#Boxplot para visualizara distribui√ß√£o do score incial por status do cliente
# Define estilo personalizado
plt.style.use('default')
fig, ax = plt.subplots(figsize=(8, 5))
fig.patch.set_facecolor('#f0f0f0')   # Fundo cinza claro do gr√°fico

# Boxplot
sns.boxplot(
    data=df_cadastral,
    x='status_cadastro',
    y='score_inicial',
    palette='Purples',
    ax=ax
)

# T√≠tulo com fonte personalizada (DIN)
plt.title(
    'Distribui√ß√£o do Score Inicial por Status do Cliente',
    fontsize=14,
    color='#555555',
    fontname='DIN Alternate',  # Ou 'DIN Condensed' dependendo do que estiver instalado
    weight='bold'
)

# Eixos
plt.xlabel('Status do Cliente')
plt.ylabel('Score Inicial')
plt.grid(axis='y', linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

"""##Unindo o DF"""

import pandas as pd  # Importa a biblioteca pandas

# 1Ô∏è‚É£ Come√ßa com o DataFrame principal: df_cadastral
df_unificado = df_cadastral.copy()
# ‚Üí Cria uma c√≥pia do DataFrame cadastral, que tem todos os clientes.

# 2Ô∏è‚É£ Junta com os dados de compras
df_unificado = pd.merge(df_unificado, df_compras, on='cliente_id', how='left')
# ‚Üí Adiciona colunas de df_compras. Quem n√£o tem compras ficar√° com campos vazios (NaN).

# 3Ô∏è‚É£ Junta com os dados de reclama√ß√µes
df_unificado = pd.merge(df_unificado, df_reclamacoes, on='cliente_id', how='left')
# ‚Üí Adiciona colunas de df_reclamacoes. Mesma l√≥gica: mant√©m todos os clientes do df_cadastral.

# 4Ô∏è‚É£ Junta com os dados de campanhas
df_unificado = pd.merge(df_unificado, df_campanhas, on='cliente_id', how='left')
# ‚Üí Adiciona colunas de df_campanhas. Sem preencher valores faltantes.

# 5Ô∏è‚É£ Exporta o DataFrame final para um arquivo CSV
df_unificado.to_csv('df_unificado_para_powerbi.csv', index=False)
# ‚Üí Exporta para CSV, pronto para importar no Power BI. Index=False evita criar uma coluna de √≠ndice desnecess√°ria.

from google.colab import files
files.download('df_unificado_para_powerbi.csv')