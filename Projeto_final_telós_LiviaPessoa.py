# -*- coding: utf-8 -*-
"""livia_projeto_final_telós.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ikm9YnOPb51qtbTr9gBh4wmh3pTUkRJl

##Importanto Bibliotecas
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""##Importando as bases"""

df_compras = pd.read_excel('/content/COMPRAS_865e1d278d.xlsx')
df_cadastral = pd.read_excel('/content/CADASTRAL.xlsx')
df_campanhas = pd.read_excel('/content/CAMPANHAS.xlsx')
df_reclamacoes = pd.read_excel('/content/RECLAMACOES.xlsx')

"""##EDA (Análise Explorátoria)"""

#Eda DF_COMPRAS
# Quantidade de Linhas
num_linhas = df_compras.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_compras.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_compras.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_compras.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_compras.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna data_compra
print("Intervalo de datas da coluna data de compra:")
print("Data mínima:", df_compras["data_compra"].min())
print("Data máxima:", df_compras["data_compra"].max())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_compras.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data mínima:", df_compras["TIMESTAMP"].min())
    print("Data máxima:", df_compras["TIMESTAMP"].max())

#Eda DF_CADASTRAL
# Quantidade de Linhas
num_linhas = df_cadastral.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_cadastral.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_cadastral.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_cadastral.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_cadastral.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_compras.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data mínima:", df_compras["TIMESTAMP"].min())
    print("Data máxima:", df_compras["TIMESTAMP"].max())

#Eda DF_CAMPANHAS
# Quantidade de Linhas
num_linhas = df_campanhas.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_campanhas.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_campanhas.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_campanhas.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_campanhas.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna data_compra
print("Intervalo de datas da coluna data de compra:")
print("Data mínima:", df_campanhas["data_envio"].min())
print("Data máxima:", df_campanhas["data_envio"].max())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_campanhas.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data mínima:", df_campanhas["TIMESTAMP"].min())
    print("Data máxima:", df_campanhas["TIMESTAMP"].max())

#Eda df_reclamacoes
# Quantidade de Linhas
num_linhas = df_reclamacoes.shape[0]
print(f"Quantidade de linhas: {num_linhas}")

# Quantidade de Colunas
num_colunas = df_reclamacoes.shape[1]
print(f"Quantidade de colunas: {num_colunas}")

# Tipos de Dados das Colunas
print("Tipos de dados das colunas:")
print(df_reclamacoes.dtypes)

# Quantidade de Valores Nulos por Coluna
print("Qtd. de Valores nulos:")
print(df_reclamacoes.isnull().sum())

# Quantidade de Valores em Branco por Coluna
print("Qtd. de Valores brancos:")
print((df_reclamacoes.applymap(lambda x: str(x).strip() == "")).sum())

# Intervalo de Datas da Coluna data_compra
print("Intervalo de datas da coluna data de compra:")
print("Data mínima:", df_reclamacoes["data_reclamacao"].min())
print("Data máxima:", df_reclamacoes["data_reclamacao"].max())

# Intervalo de Datas da Coluna TIMESTAMP
if "TIMESTAMP" in df_compras.columns:
    print("Intervalo de datas da coluna TIMESTAMP:")
    print("Data mínima:", df_reclamacoes["TIMESTAMP"].min())
    print("Data máxima:", df_reclamacoes["TIMESTAMP"].max())

from google.colab import drive
drive.mount('/content/drive')

"""##Tratamentos de dados"""

#Tratando df_compras. Identificando datas futuras
import datetime

# Pega a data de hoje
data_hoje = datetime.datetime.today()

# Filtra as linhas com data_compra maior que hoje
futuras = df_compras[df_compras['data_compra'] > data_hoje]

# Mostra a quantidade
print(f"Número de compras com data futura: {len(futuras)}")

# Remove as linhas com data_compra no futuro
df_compras = df_compras[df_compras['data_compra'] <= data_hoje]

# Mostra a quantidade
print(f"Número de compras com data futura: {len(futuras)}")

print(df_cadastral.dtypes)

#Dropando colunas " " e ".1"(Foi verificado no Google Sheets que as colunas estavam vazias)
df_cadastral = df_cadastral.drop(columns=[' ', ' .1'])

df_cadastral.columns

"""checando duplicatas"""

df_cadastral.duplicated().sum()

df_reclamacoes.duplicated().sum()

df_campanhas.duplicated().sum()

df_compras.duplicated().sum()

df_compras.dtypes

#Altera a coluna valor_compra de object para float
df_compras['valor_compra'] = df_compras['valor_compra'].astype(float)

df_compras['valor_compra'].apply(type).value_counts()#Investigando a coluna valor_compra

# Remove do DataFrame as linhas onde 'valor_compra' não pode ser convertida para float(40 linhas estavam com dados inconsistentes então eu os removi)
# Garante que apenas valores numéricos válidos permaneçam na coluna.

def is_valor_valido(valor):
    try:
        float(valor)  # testa apenas se pode ser convertido para float
        return True
    except:
        return False

# Mantém somente as linhas com valores numéricos válidos
df_compras = df_compras[df_compras['valor_compra'].apply(is_valor_valido)]

#Altera o tipo de object para float
df_compras['valor_compra'] = df_compras['valor_compra'].astype(float)

df_compras.dtypes  #verificando se o tipo foi alterado

#Contas valores nulos no df_campanhas
df_campanhas.isnull().sum()

#Investigando as linhas inconsistentes(valores nulos)
linhas_inconsistentes = df_campanhas[
    df_campanhas['tema_campanha'].isnull() |
    df_campanhas['clicou'].isnull()
]

#Dropando linhas nulas
df_campanhas = df_campanhas.drop(linhas_inconsistentes.index)

#verificando se linhas foram excluidas
df_campanhas.isnull().sum()

#verificando valores nulos no df_reclamação
df_reclamacoes.isnull().sum()

#Investigando as linhas inconsistentes(valores nulos) no df_reclamacoes
linhas_inconsistentesrec = df_reclamacoes[
    df_reclamacoes['tipo_reclamacao'].isnull() ]

print(f"Linhas inconsistentes: {len(linhas_inconsistentesrec)}")

#dropando linhas com valores nulos
df_reclamacoes = df_reclamacoes.drop(linhas_inconsistentesrec.index)

#Checando se o drop deu certo
df_reclamacoes.isnull().sum()

"""##Criando Colunas"""

#nCria nova coluna booleana para SEXO
# Padroniza e converte: masculino = True, feminino = False
df_cadastral['sexo_bool'] = df_cadastral['sexo'].str.strip().str.lower().map({
    'masculino': True,
    'feminino': False
})

#Cria 3 novas colunas booleanas para abriu, clicou, converteu_em_compra
for col in ['abriu', 'clicou', 'converteu_em_compra']:
    df_campanhas[col + '_bool'] = df_campanhas[col].str.strip().str.lower().map({
        'sim': True,
        'não': False
    })

# Agora cria a coluna 'ano_mes' no formato 'YYYY-MM'
df_compras['ano_mes'] = df_compras['data_compra'].dt.to_period('M').astype(str)

#Cria coluna ano_mes referente a data de reclamação.
df_reclamacoes['ano_mes'] = df_reclamacoes['data_reclamacao'].dt.to_period('M').astype(str)

"""#Agrupamentos"""

#Agrupar total de gastos por cliente
# Agrupar por cliente e somar o valor das compras
total_gasto_cliente = df_compras.groupby('cliente_id')['valor_compra'].sum().reset_index()

# Renomear a coluna para facilitar o uso depois
total_gasto_cliente.columns = ['cliente_id', 'total_gasto_cliente']

#Verifica qual faixa etária mais frequente dos clientes
df_cadastral['faixa_etaria'].value_counts()

#Conta o status de entrega
df_compras['status_entrega'].value_counts()

#Agrupa a quantidade de reclamação por cliente
qtd_reclamacoes = df_reclamacoes.groupby('cliente_id').size().reset_index(name='qtd_reclamacoes')

#Verifica qual canal de reclamação é o mais utilizado
canal_fav = (
    df_reclamacoes.groupby(['cliente_id', 'canal_reclamacao'])
    .size()
    .reset_index(name='qtd')
    .sort_values(['cliente_id', 'qtd'], ascending=[True, False])
    .drop_duplicates('cliente_id')
    .rename(columns={'canal_reclamacao': 'canal_mais_usado_reclamacao'})
)

#Quais canais de campanhas de marketing mais convertem
# Ensure 'converteu_em_compra' is in a suitable format (boolean) for summation
df_campanhas['converteu_em_compra_bool'] = df_campanhas['converteu_em_compra'].str.strip().str.lower().map({
    'sim': True,
    'não': False
})

canal_conv = df_campanhas.groupby('canal').agg(
    total_envios=('cliente_id', 'count'),
    total_conversoes=('converteu_em_compra_bool', 'sum') # Sum the boolean column
).reset_index()

canal_conv['taxa_conversao'] = (canal_conv['total_conversoes'] / canal_conv['total_envios']) * 100

# Visualizar ordenado
canal_conv.sort_values(by='taxa_conversao', ascending=False)

# Total de compras por cliente
compras_agg = df_compras.groupby('cliente_id').agg({
    'valor_compra': 'sum',
    'data_compra': 'count',
    'quantidade_parcelas': 'sum'
}).rename(columns={
    'valor_compra': 'total_gasto',
    'data_compra': 'num_compras',
    'quantidade_parcelas': 'total_parcelas'
})

# Total de conversões por cliente
campanhas_agg = df_campanhas.groupby('cliente_id').agg({
    'converteu_em_compra_bool': 'sum'
}).rename(columns={'converteu_em_compra_bool': 'total_conversoes'})

# Merge com df_cadastral
df_financeiro = df_cadastral.merge(compras_agg, on='cliente_id', how='left') \
                            .merge(campanhas_agg, on='cliente_id', how='left')

#A partir desse código começa um relacionamento entre clientes inativos e score inicial
#Visa descobrir se a porcentagem de clientes inativos (71%) tem a ver com o score dos clientes(Que em sua maioria fica entre 400 e 500 pontos)
df_cadastral['status_cadastro'].value_counts()

#Cria dois grupos de clientes "Ativos e Inativos"
ativos = df_cadastral[df_cadastral['status_cadastro'] == 'Ativo']
inativos = df_cadastral[df_cadastral['status_cadastro'] == 'Inativo']

#Média de Score por Grupo
df_cadastral.groupby('status_cadastro')['score_inicial'].mean()

"""# Visualizações"""

#Visualização da quantidades de clientes cadastrados por faixa etária
import matplotlib.pyplot as plt
import seaborn as sns

# Estilo
sns.set(style="whitegrid")

# Contagem por faixa etária
contagem_faixas = df_cadastral['faixa_etaria'].value_counts().sort_index()

# Paleta azul, roxo e lilás (repete se tiver mais faixas)
cores_personalizadas = ['#6495ED', '#6A0DAD', '#C8A2C8'] * 3

# Cria a figura com fundo cinza claro
plt.figure(figsize=(10, 6), facecolor='#f2f2f2')

# Gráfico
ax = sns.barplot(
    x=contagem_faixas.index,
    y=contagem_faixas.values,
    palette=cores_personalizadas[:len(contagem_faixas)]
)

# Fundo do gráfico
ax.set_facecolor('#f9f9f9')

# Títulos
plt.title('Distribuição de Clientes por Faixa Etária', fontsize=16, weight='bold')
plt.xlabel('Faixa Etária', fontsize=12)
plt.ylabel('Número de Clientes', fontsize=12)
plt.xticks(rotation=45)

# Remove bordas extras
sns.despine()
plt.tight_layout()

plt.show()

#Distribuição de Status de Entrega

# Contagem dos status de entrega
status_counts = df_compras['status_entrega'].value_counts()

# Cores personalizadas: azul, roxo e lilás
cores = ['#6495ED', '#6A0DAD', '#C8A2C8']

# Criar figura com fundo cinza claro
plt.figure(figsize=(7,7), facecolor='#f2f2f2')

# Plotar gráfico de pizza
plt.pie(
    status_counts,
    labels=status_counts.index,
    autopct='%1.1f%%',
    colors=cores,
    startangle=140,
    textprops={'color':"black", 'fontsize':12}
)

plt.title('Distribuição do Status de Entrega', fontsize=16, weight='bold')

# Mostrar gráfico
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.font_manager as fm
import numpy as np

# Taxa de conversão por canal
canal_conv = df_campanhas.groupby('canal').agg(
    total_envios=('cliente_id', 'count'),
    total_conversoes=('converteu_em_compra_bool', 'sum')
).reset_index()

canal_conv['taxa_conversao'] = (canal_conv['total_conversoes'] / canal_conv['total_envios']) * 100

# Ordena pelo maior valor de taxa de conversão
canal_conv = canal_conv.sort_values('taxa_conversao', ascending=False).reset_index(drop=True)

# Geração de cores em degradê (roxo escuro para lilás claro)
from matplotlib.colors import LinearSegmentedColormap

# Cria um gradiente de cores do roxo escuro ao lilás
cmap = LinearSegmentedColormap.from_list("roxo_lilas", ["#483D8B", "#D8BFD8"])
norm = plt.Normalize(canal_conv['taxa_conversao'].min(), canal_conv['taxa_conversao'].max())
colors = [cmap(norm(val)) for val in canal_conv['taxa_conversao']]

# Plot
plt.figure(figsize=(8, 5))
barplot = sns.barplot(
    data=canal_conv,
    x='taxa_conversao',
    y='canal',
    palette=colors
)

# Adiciona o percentual ao lado das barras
for i, valor in enumerate(canal_conv['taxa_conversao']):
    plt.text(valor + 0.5, i, f'{valor:.1f}%', va='center', fontsize=10, color='black')

# Fonte personalizada (DIN) se disponível
# Substitua o caminho abaixo pelo caminho local da sua fonte, se necessário
# fm.fontManager.addfont('/caminho/para/sua/fonte/DIN-Regular.ttf')
# plt.rcParams['font.family'] = 'DIN'

# Estilo do título
plt.title('📡 Taxa de Conversão por Canal de Campanha',
          fontsize=14, color='#4F4F4F', fontweight='bold', fontname='DIN')

plt.xlabel('Taxa de Conversão (%)')
plt.ylabel('Canal')
plt.grid(axis='x', linestyle='--', alpha=0.4)
plt.gca().set_facecolor('#f0f0f0')
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import matplotlib.font_manager as fm
import numpy as np

# Normalização dos dados
df_campanhas['abriu'] = df_campanhas['abriu'].str.strip().str.lower()
df_campanhas['clicou'] = df_campanhas['clicou'].str.strip().str.lower()
df_campanhas['converteu_em_compra'] = df_campanhas['converteu_em_compra'].str.strip().str.lower()

# Cálculo das taxas
abriu_sim = df_campanhas['abriu'].value_counts(normalize=True).get('sim', 0) * 100
clicou_sim = df_campanhas['clicou'].value_counts(normalize=True).get('sim', 0) * 100
converteu_sim = df_campanhas['converteu_em_compra'].value_counts(normalize=True).get('sim', 0) * 100

# Estrutura do funil
funnel_data = {
    'Etapa': ['Campanhas Enviadas', 'Campanhas Abertas', 'Cliques', 'Conversões'],
    'Taxa (%)': [100, abriu_sim, clicou_sim, converteu_sim]
}
funnel_df = pd.DataFrame(funnel_data)

# Degradê de cores: roxo (valor alto) para lilás (valor baixo)
cmap = LinearSegmentedColormap.from_list("degrade_roxo_lilas", ['#6A0DAD', '#E6ADD8'])
norm = plt.Normalize(funnel_df['Taxa (%)'].min(), funnel_df['Taxa (%)'].max())
colors = [cmap(norm(val)) for val in funnel_df['Taxa (%)']]

# Plot
fig, ax = plt.subplots(figsize=(8, 6))
bars = ax.barh(funnel_df['Etapa'], funnel_df['Taxa (%)'], color=colors)

# Rótulos nas barras
for bar in bars:
    width = bar.get_width()
    ax.text(width - 3, bar.get_y() + bar.get_height()/2,
            f'{width:.1f}%', ha='right', va='center',
            fontsize=10, color='white')

# Fonte personalizada (DIN)
# Se a fonte DIN não estiver instalada, substitua pelo caminho do arquivo .ttf:
# fm.fontManager.addfont('/caminho/para/DIN.ttf')
# plt.rcParams['font.family'] = 'DIN'
plt.title('🔻 Funil de Engajamento e Conversão',
          fontsize=14, color='#4F4F4F', fontweight='bold', fontname='DIN')

# Estilo do gráfico
ax.set_xlim(0, 110)
ax.set_xlabel('Percentual (%)')
ax.set_facecolor('#f0f0f0')
plt.grid(axis='x', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.colors as mcolors
import numpy as np

# Ordenar os dados por taxa de conversão (do maior pro menor)
canal_conv = canal_conv.sort_values(by='taxa_conversao', ascending=False).reset_index(drop=True)

# Criar gradiente de roxo escuro até lilás com base na quantidade de canais
cmap = mcolors.LinearSegmentedColormap.from_list("roxo_lilas", ["#4B0082", "#D8BFD8"])  # Roxo escuro -> Lilás
cores_gradiente = [cmap(i / (len(canal_conv) - 1)) for i in range(len(canal_conv))]

# Estilo
sns.set(style="whitegrid")
plt.figure(figsize=(10, 6))
plt.gca().set_facecolor('#f7f7f7')  # Fundo cinza bem clarinho

# Criar o gráfico de barras
barras = sns.barplot(
    data=canal_conv,
    x='taxa_conversao',
    y='canal',
    palette=cores_gradiente
)

# Adicionar rótulos de valor nas barras
for container in barras.containers:
    barras.bar_label(container, fmt="%.1f%%", label_type='edge', padding=5)

# Títulos e labels
plt.title('Taxa de Conversão por Canal de Campanha', fontsize=14, weight='bold')
plt.xlabel('Taxa de Conversão (%)')
plt.ylabel('Canal')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
sns.histplot(
    data=df_cadastral,
    x='score_inicial',
    bins=30,
    kde=True,
    color='mediumpurple'
)
plt.title('Distribuição do Score Inicial')
plt.xlabel('Score Inicial')
plt.ylabel('Quantidade de Clientes')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

#Boxplot para visualizara distribuição do score incial por status do cliente
# Define estilo personalizado
plt.style.use('default')
fig, ax = plt.subplots(figsize=(8, 5))
fig.patch.set_facecolor('#f0f0f0')   # Fundo cinza claro do gráfico

# Boxplot
sns.boxplot(
    data=df_cadastral,
    x='status_cadastro',
    y='score_inicial',
    palette='Purples',
    ax=ax
)

# Título com fonte personalizada (DIN)
plt.title(
    'Distribuição do Score Inicial por Status do Cliente',
    fontsize=14,
    color='#555555',
    fontname='DIN Alternate',  # Ou 'DIN Condensed' dependendo do que estiver instalado
    weight='bold'
)

# Eixos
plt.xlabel('Status do Cliente')
plt.ylabel('Score Inicial')
plt.grid(axis='y', linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

"""##Unindo o DF"""

import pandas as pd  # Importa a biblioteca pandas

# 1️⃣ Começa com o DataFrame principal: df_cadastral
df_unificado = df_cadastral.copy()
# → Cria uma cópia do DataFrame cadastral, que tem todos os clientes.

# 2️⃣ Junta com os dados de compras
df_unificado = pd.merge(df_unificado, df_compras, on='cliente_id', how='left')
# → Adiciona colunas de df_compras. Quem não tem compras ficará com campos vazios (NaN).

# 3️⃣ Junta com os dados de reclamações
df_unificado = pd.merge(df_unificado, df_reclamacoes, on='cliente_id', how='left')
# → Adiciona colunas de df_reclamacoes. Mesma lógica: mantém todos os clientes do df_cadastral.

# 4️⃣ Junta com os dados de campanhas
df_unificado = pd.merge(df_unificado, df_campanhas, on='cliente_id', how='left')
# → Adiciona colunas de df_campanhas. Sem preencher valores faltantes.

# 5️⃣ Exporta o DataFrame final para um arquivo CSV
df_unificado.to_csv('df_unificado_para_powerbi.csv', index=False)
# → Exporta para CSV, pronto para importar no Power BI. Index=False evita criar uma coluna de índice desnecessária.

from google.colab import files
files.download('df_unificado_para_powerbi.csv')